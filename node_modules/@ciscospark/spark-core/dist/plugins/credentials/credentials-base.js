'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _clone = require('lodash/clone');

var _clone2 = _interopRequireDefault(_clone);

var _apply = require('babel-runtime/core-js/reflect/apply');

var _apply2 = _interopRequireDefault(_apply);

var _isObject = require('lodash/isObject');

var _isObject2 = _interopRequireDefault(_isObject);

var _has = require('lodash/has');

var _has2 = _interopRequireDefault(_has);

var _promise = require('babel-runtime/core-js/promise');

var _promise2 = _interopRequireDefault(_promise);

var _pick = require('lodash/pick');

var _pick2 = _interopRequireDefault(_pick);

var _authorization = require('./authorization');

var _authorization2 = _interopRequireDefault(_authorization);

var _common = require('@ciscospark/common');

var _grantErrors = require('./grant-errors');

var _grantErrors2 = _interopRequireDefault(_grantErrors);

var _querystring = require('querystring');

var _querystring2 = _interopRequireDefault(_querystring);

var _sparkPlugin = require('../../lib/spark-plugin');

var _sparkPlugin2 = _interopRequireDefault(_sparkPlugin);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Helper. Returns just the response body
 * @param {http.IncomingMessage} res
 * @returns {Object}
 */
function resolveWithResponseBody(res) {
  return res.body;
}

/**
 * Helper. Converts a response body into an Authorization object
 * @param {http.IncomingMessage} res
 * @returns {Authorization}
 */
/**!
 *
 * Copyright (c) 2015 Cisco Systems, Inc. See LICENSE file.
 * @private
 */

function processGrant(res) {
  return new _authorization2.default(res.body);
}

var CredentialsBase = _sparkPlugin2.default.extend({
  derived: {
    canRefresh: {
      deps: ['authorization.canRefresh'],
      fn: function fn() {
        /* eslint camelcase: [0] */
        return Boolean(this.config.oauth.client_id && this.config.oauth.client_secret && this.authorization && this.authorization.canRefresh);
      }
    },
    isAuthenticated: {
      deps: ['authorization.isAuthenticated'],
      fn: function fn() {
        return Boolean(this.authorization && this.authorization.isAuthenticated);
      }
    },
    isAuthenticating: {
      deps: ['authorization.isRefreshing', '_isAuthenticating'],
      fn: function fn() {
        return this._isAuthenticating || this.authorization && this.authorization.isRefreshing;
      }
    },
    isExpired: {
      deps: ['authorization.isExpired'],
      fn: function fn() {
        return Boolean(this.authorization && this.authorization.isExpired);
      }
    }
  },

  namespace: 'Credentials',

  props: {
    authorization: {
      type: 'state'
    },
    clientAuthorization: {
      type: 'state'
    },
    name: {
      setOnce: true,
      type: 'string'
    },
    orgId: {
      setOnce: true,
      type: 'string'
    }
  },

  session: {
    _isAuthenticating: {
      default: false,
      type: 'boolean'
    },
    password: 'string',
    previousAuthorization: {
      type: 'state'
    }
  },

  authenticate: function authenticate() {
    return this.authorize.apply(this, arguments);
  },


  authorize: (0, _common.oneFlight)('authorize', function authenticate(options) {
    var _this = this;

    /* eslint no-invalid-this: [0] */
    this._isAuthenticating = true;
    options = options || {};
    if (options.code) {
      this.logger.info('credentials: auth code received, exchanging for access_token');
      return this.requestAuthorizationCodeGrant(options).then(function (res) {
        _this._isAuthenticating = false;
        return res;
      });
    }

    if (this.canRefresh) {
      this.logger.info('credentials: refreshable, refreshing');
      return this.refresh(options).then(function (res) {
        _this._isAuthenticating = false;
        return res;
      });
    }

    this.set((0, _pick2.default)(options, 'name', 'orgId', 'password'));

    if (this.name && this.orgId && this.password) {
      this.logger.info('credentials: machine credentials received, authenticating');
      return this.requestSamlExtensionGrant(options).then(function (res) {
        _this._isAuthenticating = false;
        return res;
      }).catch(function (res) {
        _this._isAuthenticating = false;
        return _promise2.default.reject(res);
      });
    }

    this._isAuthenticating = false;
    return _promise2.default.reject(new Error('not enough parameters to authenticate'));
  }),

  getAuthorization: (0, _common.oneFlight)('getAuthorization', function getAuthorization() {
    var _this2 = this;

    if (this.isAuthenticated) {
      if (this.isExpired) {
        if (this.canRefresh) {
          return this.refresh().then(function () {
            return _this2.authorization.toString();
          });
        }

        return _promise2.default.reject(new Error('Access token has expired or cannot be refreshed'));
      }

      return _promise2.default.resolve(this.authorization.toString());
    }

    return _promise2.default.reject(new Error('not authenticated'));
  }),

  getClientAuthorization: (0, _common.oneFlight)('getClientCredentialsAuthorization', function getClientCredentialsAuthorization() {
    var _this3 = this;

    var promise = void 0;
    if (!this.clientAuthorization || !this.clientAuthorization.isAuthenticated || this.clientAuthorization.isExpired) {
      promise = this.requestClientCredentialsGrant();
    } else {
      promise = _promise2.default.resolve();
    }

    return promise.then(function () {
      return _this3.clientAuthorization.toString();
    });
  }),

  /**
   * @returns {Promise}
   */
  logout: function logout() {
    var _this4 = this;

    return _promise2.default.all(['authorization', 'previousAuthorization'].map(function (key) {
      if (_this4[key]) {
        return _this4[key].revoke().catch(function (reason) {
          _this4.logger.error('credentials: ' + key + ' revocation falied', reason);
        });
      }
      return _promise2.default.resolve();
    }));
  },


  /**
   * Refreshes credentials with a refresh token
   * @param {Object} options
   * @param {Object} options.force If true, refresh the token even if the token
   * appears unexpired
   * @returns {Promise} Resolves when credentials have been refreshed
   */
  refresh: (0, _common.oneFlight)('refresh', function refresh(options) {
    /* eslint no-invalid-this: [0] */
    this.logger.info('credentials: refresh requested');

    options = options || {};

    if (!options.force && !this.authorization.isExpired) {
      this.logger.info('credentials: authorization not expired, not refreshing');
      return _promise2.default.resolve();
    }

    this.logger.info('credentials: refreshing');

    return this.authorization.refresh(options).then(this._pushAuthorization.bind(this)).catch(this._handleRefreshFailure.bind(this));
  }),

  requestAuthorizationCodeGrant: (0, _common.oneFlight)('requestAuthorizationCodeGrant', function requestAuthorizationCodeGrant(options) {
    var vars = {
      'oauth.client_id': 'CLIENT_ID',
      'oauth.client_secret': 'CLIENT_SECRET',
      'oauth.redirect_uri': 'REDIRECT_URI'
    };

    for (var key in vars) {
      if (!(0, _has2.default)(this.config, key)) {
        var baseVar = vars[key];
        return _promise2.default.reject(new Error('config.credentials.' + key + ' or CISCOSPARK_' + baseVar + ' or COMMON_IDENTITY_' + baseVar + ' or ' + baseVar + ' must be defined'));
      }
    }

    /* eslint camelcase: [0] */
    this.logger.info('credentials: requesting authorization code grant');

    options = options || {};
    options.scope = options.scope || this.config.oauth.scope;

    if (!options.code) {
      return _promise2.default.reject(new Error('`options.code` is required'));
    }

    return this.request({
      method: 'POST',
      uri: this.config.oauth.tokenUrl,
      form: {
        grant_type: 'authorization_code',
        redirect_uri: this.config.oauth.redirect_uri,
        code: options.code
      },
      auth: {
        user: this.config.oauth.client_id,
        pass: this.config.oauth.client_secret,
        sendImmediately: true
      },
      shouldRefreshAccessToken: false
    }).then(processGrant).then(this._pushAuthorization.bind(this)).catch(function (res) {
      if (res.statusCode !== 400) {
        return _promise2.default.reject(res);
      }

      var ErrorConstructor = _grantErrors2.default.select(res.body.error);
      return _promise2.default.reject(new ErrorConstructor(res._res || res));
    });
  }),

  requestClientCredentialsGrant: (0, _common.oneFlight)('requestClientCredentialsGrant', function requestClientCredentialsGrant(options) {
    var vars = {
      'oauth.client_id': 'CLIENT_ID',
      'oauth.client_secret': 'CLIENT_SECRET'
    };

    for (var key in vars) {
      if (!(0, _has2.default)(this.config, key)) {
        var baseVar = vars[key];
        return _promise2.default.reject(new Error('config.credentials.' + key + ' or CISCOSPARK_' + baseVar + ' or COMMON_IDENTITY_' + baseVar + ' or ' + baseVar + ' must be defined'));
      }
    }

    this.logger.info('credentials: requesting client credentials grant');

    options = options || {};
    // Right now, admin is the only service that needs Client Credentials,
    // so we`ll hard code that here. long term, we`ll want to keep track of
    // scope used to request a specific token and (potentially) specify
    // scope as an options passed to Clinet#request so it can pick the right
    // token.
    options.scope = options.scope || 'webexsquare:admin';

    return this.request({
      method: 'POST',
      uri: this.config.oauth.tokenUrl,
      form: {
        grant_type: 'client_credentials',
        scope: options.scope,
        shouldRefreshAccessToken: false
      },
      auth: {
        user: this.config.oauth.client_id,
        pass: this.config.oauth.client_secret,
        sendImmediately: true
      }
    }).then(processGrant).then(this._pushClientCredentialsAuthorization.bind(this)).catch(function (res) {
      if (res.statusCode !== 400) {
        return _promise2.default.reject(res);
      }

      var ErrorConstructor = _grantErrors2.default.select(res.body.error);
      return _promise2.default.reject(new ErrorConstructor(res._res || res));
    });
  }),

  requestSamlExtensionGrant: (0, _common.oneFlight)('requestSamlExtensionGrant', (0, _common.retry)(function requestSamlExtensionGrant(options) {
    options = options || {};
    options.scope = options.scope || this.config.oauth.scope;

    this.logger.info('credentials: requesting SAML extension grant');

    return this._getSamlBearerToken(options).then(this._getOauthBearerToken.bind(this, options)).then(processGrant).then(this._pushAuthorization.bind(this)).catch(function (res) {
      if (res.statusCode !== 400) {
        return _promise2.default.reject(res);
      }

      var ErrorConstructor = _grantErrors2.default.select(res.body.error);
      return _promise2.default.reject(new ErrorConstructor(res._res || res));
    });
  })),

  set: function set(key, value) {
    var _this5 = this;

    var attrs = void 0;
    if ((0, _isObject2.default)(key)) {
      attrs = key;
    } else {
      attrs = {};
      attrs[key] = value;
    }

    ['authorization', 'clientAuthorization', 'previousAuthorization'].forEach(function (propName) {
      if (attrs[propName]) {
        if (!(attrs[propName] instanceof _authorization2.default)) {
          attrs[propName] = new _authorization2.default(attrs[propName]);
        }
        attrs[propName].parent = _this5;
      }
    });

    /* eslint prefer-rest-params: [0] */
    return (0, _apply2.default)(_sparkPlugin2.default.prototype.set, this, arguments);
  },
  _buildLogoutUrl: function _buildLogoutUrl() {
    // eslint doesn't yet handle nested strings quite right
    /* eslint quotes: [0] */
    return this.config.logoutUri + '?' + _querystring2.default.stringify({
      type: 'logout',
      goto: this.config.oauth.redirect_uri,
      service: this.config.oauth.service
    });
  },


  _buildOAuthUrl: function _buildOAuthUrl(options) {
    var _this6 = this;

    /* eslint camelcase: [0] */
    var fields = ['client_id', 'redirect_uri', 'scope', 'service'];

    var parameters = (0, _clone2.default)(options);

    parameters.state = parameters.state || {};
    if (!(0, _isObject2.default)(parameters.state)) {
      throw new Error('if specified, `options.state` must be an object');
    }

    if (!parameters.response_type) {
      throw new Error('`options.response_type` is required');
    }

    fields.forEach(function (key) {
      if (key in _this6.config.oauth) {
        parameters[key] = _this6.config.oauth[key];
      } else {
        throw new Error('`' + key + '` is required');
      }
    }, this);

    // Some browser aparently don't parse nested querystrings very well, so
    // we'll additionally base64url-encode the state
    parameters.state = _common.base64.toBase64Url(_querystring2.default.stringify(parameters.state));
    return this.config.oauth.authorizationUrl + '?' + _querystring2.default.stringify(parameters);
  },

  /**
   * Converts a CI SAML Bearer Token to an OAuth Bearer Token.
   * @param {Object} options
   * @param {Object} options.scope
   * @param {Object} samlData Response body from the CI SAML endpoint.
   * @private
   * @return {Promise} Resolves with the bot's credentials.
   */
  _getOauthBearerToken: (0, _common.oneFlight)('_getOauthBearerToken', function _getOauthBearerToken(options, samlData) {
    this.logger.info('credentials: exchanging SAML Bearer Token for OAuth Bearer Token');

    var vars = {
      'oauth.client_id': 'CLIENT_ID',
      'oauth.client_secret': 'CLIENT_SECRET'
    };

    for (var key in vars) {
      if (!(0, _has2.default)(this.config, key)) {
        var baseVar = vars[key];
        return _promise2.default.reject(new Error('config.credentials.' + key + ' or CISCOSPARK_' + baseVar + ' or COMMON_IDENTITY_' + baseVar + ' or ' + baseVar + ' must be defined'));
      }
    }

    return this.request({
      method: 'POST',
      uri: this.config.oauth.tokenUrl,
      form: {
        /* eslint camelcase: [0] */
        grant_type: 'urn:ietf:params:oauth:grant-type:saml2-bearer',
        assertion: samlData.BearerToken,
        scope: options.scope
      },
      auth: {
        user: this.config.oauth.client_id,
        pass: this.config.oauth.client_secret,
        sendImmediately: true
      },
      shouldRefreshAccessToken: false
    });
  }),

  /**
   * Retrieves a CI SAML Bearer Token
   * @private
   * @return {Promise} Resolves with an Object containing a `BearerToken` and an
   * `AccountExpires`
   */
  _getSamlBearerToken: (0, _common.oneFlight)('_getSamlBearerToken', function _getSamlBearerToken() {
    this.logger.info('credentials: requesting SAML Bearer Token');

    if (!this.orgId) {
      return _promise2.default.reject(new Error('`this.orgId` is required'));
    }

    if (!this.name) {
      return _promise2.default.reject(new Error('`this.name` is required'));
    }

    if (!this.password) {
      return _promise2.default.reject(new Error('`this.password` is required'));
    }

    return this.request({
      method: 'POST',
      uri: '{this.config.samlUrl}/{$this.orgId}/v2/actions/GetBearerToken/invoke',
      body: (0, _pick2.default)(this, 'name', 'password'),
      shouldRefreshAccessToken: false
    }).then(resolveWithResponseBody);
  }),

  _handleRefreshFailure: function _handleRefreshFailure(res) {
    if (res.error && res.error === 'invalid_request') {
      this.logger.warn('token refresh failed: ', res.errorDescription);
      this.unset('authorization');
    }

    return _promise2.default.reject(res);
  },

  _pushClientCredentialsAuthorization: function _pushClientCredentialsAuthorization(authorization) {
    this.logger.info('credentials: received client credentials');

    this.clientAuthorization = authorization;
  },

  _pushAuthorization: function _pushAuthorization(authorization) {
    this.logger.info('credentials: received authorization');

    var previousAuthorization = this.previousAuthorization;
    this.previousAuthorization = this.authorization;
    this.authorization = authorization;

    if (previousAuthorization) {
      previousAuthorization.revoke();
    }
  }

});

exports.default = CredentialsBase;
//# sourceMappingURL=credentials-base.js.map
