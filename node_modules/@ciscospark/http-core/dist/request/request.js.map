{"version":3,"sources":["../../src/request/request.js"],"names":[],"mappings":";;;;;;;;;;kBA+EwB,Q;;AA1ExB;;;;AACA;;;;AACA;;;;;;AAEA;;;;;AAKA,SAAS,cAAT,CAAwB,OAAxB,EAAiC;AAC/B,MAAI,QAAQ,YAAR,iBAAqC,QAAQ,YAAR,WAAzC,EAA0E;AACxE,YAAQ,QAAR,GAAmB,IAAnB;AACD;;AAED,MAAI,QAAQ,eAAZ,EAA6B;AAC3B,YAAQ,GAAR,GAAc,IAAd;AACD;;AAED,MAAI,OAAO,QAAP,CAAgB,QAAQ,IAAxB,CAAJ,EAAmC;AACjC,WAAO,sBAAO,QAAQ,IAAf,EACJ,IADI,CACC,UAAC,IAAD,EAAU;AACd,cAAQ,OAAR,mBAAkC,IAAlC;AACA,aAAO,OAAP;AACD,KAJI,CAAP;AAKD;;AAED,SAAO,kBAAQ,OAAR,CAAgB,OAAhB,CAAP;AACD;;AAED;;;;;AAlCA;;;;;AAuCA,SAAS,SAAT,CAAmB,OAAnB,EAA4B;AAC1B,SAAO,sBAAY,UAAC,OAAD,EAAa;AAC9B,QAAM,IAAI,uBAAQ,OAAR,EAAiB,UAAC,KAAD,EAAQ,QAAR,EAAqB;AAC9C,UAAI,KAAJ,EAAW;AACT,gBAAQ,MAAR,CAAe,IAAf,CAAoB,KAApB;AACD;;AAED,UAAI,QAAJ,EAAc;AACZ,iBAAS,OAAT,GAAmB,OAAnB;AACA,gBAAQ,QAAR;AACD,OAHD,MAIK;AACH;AACA,gBAAQ;AACN,sBAAY,CADN;AAEN,0BAFM;AAGN,mBAAS,QAAQ,OAHX;AAIN,kBAAQ,QAAQ,MAJV;AAKN,eAAK,QAAQ,GALP;AAMN,gBAAM;AANA,SAAR;AAQD;AACF,KApBS,CAAV;;AAsBA,MAAE,EAAF,aAAiB,UAAC,QAAD,EAAc;AAC7B,UAAM,QAAQ,SAAS,SAAS,OAAT,kBAAT,EAA6C,EAA7C,CAAd;AACA,UAAI,SAAS,CAAb;AACA,eAAS,EAAT,SAAoB,UAAC,IAAD,EAAU;AAC5B,kBAAU,KAAK,MAAf;AACA,gBAAQ,QAAR,CAAiB,IAAjB,aAAkC,4BAAkB,MAAlB,EAA0B,KAA1B,CAAlC;AACD,OAHD;AAID,KAPD;AAQD,GA/BM,CAAP;AAgCD;;AAED;;;;;AAKe,SAAS,QAAT,CAAkB,OAAlB,EAA2B;AACxC,SAAO,eAAe,OAAf,EACJ,IADI,CACC,SADD,CAAP;AAED","file":"request.js","sourcesContent":["/**!\n *\n * Copyright (c) 2015-2016 Cisco Systems, Inc. See LICENSE file.\n */\n\nimport detect from '../lib/detect';\nimport ProgressEvent from '../progress-event';\nimport request from 'request';\n\n/**\n * @param {Object} options\n * @private\n * @returns {Promise}\n */\nfunction prepareOptions(options) {\n  if (options.responseType === `buffer` || options.responseType === `blob`) {\n    options.encoding = null;\n  }\n\n  if (options.withCredentials) {\n    options.jar = true;\n  }\n\n  if (Buffer.isBuffer(options.body)) {\n    return detect(options.body)\n      .then((type) => {\n        options.headers[`content-type`] = type;\n        return options;\n      });\n  }\n\n  return Promise.resolve(options);\n}\n\n/**\n * @param {Object} options\n * @private\n * @returns {Promise}\n */\nfunction doRequest(options) {\n  return new Promise((resolve) => {\n    const r = request(options, (error, response) => {\n      if (error) {\n        options.logger.warn(error);\n      }\n\n      if (response) {\n        response.options = options;\n        resolve(response);\n      }\n      else {\n        // Make a network error behave like a browser network error.\n        resolve({\n          statusCode: 0,\n          options,\n          headers: options.headers,\n          method: options.method,\n          url: options.url,\n          body: error\n        });\n      }\n    });\n\n    r.on(`response`, (response) => {\n      const total = parseInt(response.headers[`content-length`], 10);\n      let loaded = 0;\n      response.on(`data`, (data) => {\n        loaded += data.length;\n        options.download.emit(`progress`, new ProgressEvent(loaded, total));\n      });\n    });\n  });\n}\n\n/**\n * @name request\n * @param {Object} options\n * @returns {Promise}\n */\nexport default function _request(options) {\n  return prepareOptions(options)\n    .then(doRequest);\n}\n"]}