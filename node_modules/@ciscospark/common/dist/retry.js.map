{"version":3,"sources":["../src/retry.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;kBAsBwB,a;;AAhBxB;;AACA;;;;;;AAEA;;;;;;;;;;;;;AAae,SAAS,aAAT,CAAuB,EAAvB,EAA2B,OAA3B,EAAoC;AACjD,MAAI,CAAC,0BAAW,EAAX,CAAL,EAAqB;AACnB,UAAM,IAAI,KAAJ,2BAAN;AACD;;AAED,YAAU,WAAW,EAArB;;AAEA,0BAAS,OAAT,EAAkB;AAChB,aAAS,IADO;AAEhB,WAAO,CAFS;AAGhB,iBAAa;AAHG,GAAlB;;AAMA,MAAI,wBAAJ;AACA,MAAI,QAAQ,OAAZ,EAAqB;AACnB,sBAAkB;AAChB,oBAAc,QAAQ,KADN;AAEhB,gBAAU,QAAQ;AAFF,KAAlB;AAID,GALD,MAMK;AACH,sBAAkB;AAChB,oBAAc,CADE;AAEhB,gBAAU;AAFM,KAAlB;AAID;;AAED,SAAO,SAAS,KAAT,GAAwB;AAAA;;AAAA,sCAAN,IAAM;AAAN,UAAM;AAAA;;AAC7B,QAAM,UAAU,0BAAhB;AACA,QAAM,UAAU,sBAAY,UAAC,OAAD,EAAU,MAAV,EAAqB;AAC/C;AACA;AACA;AACA,UAAM,OAAO,kBAAQ,IAAR,CACX,UAAC,EAAD,EAAQ;AACN;AACA,YAAM,eAAe,4BAAoB,EAApB,EAAwB,IAAxB,CAArB;;AAEA,YAAI,0BAAW,aAAa,EAAxB,CAAJ,EAAiC;AAC/B,uBAAa,EAAb,aAA4B,QAAQ,IAAR,CAAa,IAAb,CAAkB,OAAlB,aAA5B;AACA,uBAAa,EAAb,oBAAmC,QAAQ,IAAR,CAAa,IAAb,CAAkB,OAAlB,oBAAnC;AACA,uBAAa,EAAb,sBAAqC,QAAQ,IAAR,CAAa,IAAb,CAAkB,OAAlB,sBAArC;AACD;;AAED,eAAO,aACJ,IADI,CACC,UAAC,GAAD,EAAS;AACb,aAAG,IAAH,EAAS,GAAT;AACD,SAHI,EAIJ,KAJI,CAIE,UAAC,MAAD,EAAY;AACjB,cAAI,CAAC,MAAL,EAAa;AACX,qBAAS,IAAI,KAAJ,6DAAT;AACD;AACD,aAAG,MAAH;AACD,SATI,CAAP;AAUD,OArBU,EAsBX,UAAC,GAAD,EAAM,GAAN,EAAc;AACZ,YAAI,GAAJ,EAAS;AACP,iBAAO,OAAO,GAAP,CAAP;AACD;;AAED,eAAO,QAAQ,GAAR,CAAP;AACD,OA5BU,CAAb;;AA+BA,WAAK,WAAL,CAAiB,IAAI,kBAAQ,mBAAZ,CAAgC,eAAhC,CAAjB;AACA,UAAI,QAAQ,WAAZ,EAAyB;AACvB,aAAK,SAAL,CAAe,QAAQ,WAAR,GAAsB,CAArC;AACD;;AAED,WAAK,KAAL;AACD,KAzCe,CAAhB;;AA2CA,YAAQ,EAAR,GAAa,SAAS,EAAT,CAAY,GAAZ,EAAiB,QAAjB,EAA2B;AACtC,cAAQ,EAAR,CAAW,GAAX,EAAgB,QAAhB;AACA,aAAO,OAAP;AACD,KAHD;;AAKA,WAAO,OAAP;AACD,GAnDD;AAoDD,CArGD","file":"retry.js","sourcesContent":["/**!\n *\n * Copyright (c) 2015-2016 Cisco Systems, Inc. See LICENSE file.\n */\n\nimport {defaults, isFunction} from 'lodash';\nimport {EventEmitter} from 'events';\nimport backoff from 'backoff';\n\n/**\n * Makes a promise-returning method retryable according to the specified backoff\n * pattern\n * @param {Function} fn\n * @param {Object} options\n * @param {boolean} options.backoff\n * @param {number} options.delay\n * @param {number} options.initialDelay\n * @param {number} options.maxAttempts\n * @param {number} options.maxDelay\n *\n * @returns {Function}\n */\nexport default function makeRetryable(fn, options) {\n  if (!isFunction(fn)) {\n    throw new Error(`\\`fn\\` must be a function`);\n  }\n\n  options = options || {};\n\n  defaults(options, {\n    backoff: true,\n    delay: 1,\n    maxAttempts: 3\n  });\n\n  let strategyOptions;\n  if (options.backoff) {\n    strategyOptions = {\n      initialDelay: options.delay,\n      maxDelay: options.maxDelay\n    };\n  }\n  else {\n    strategyOptions = {\n      initialDelay: 1,\n      maxDelay: 1\n    };\n  }\n\n  return function retry(...args) {\n    const emitter = new EventEmitter();\n    const promise = new Promise((resolve, reject) => {\n      // backoff.call is not Function.prototype.call; it's an unfortunate naming\n      // collision.\n      /* eslint prefer-reflect: [0] */\n      const call = backoff.call(\n        (cb) => {\n          /* eslint no-invalid-this: [0] */\n          const innerPromise = Reflect.apply(this, fn, args);\n\n          if (isFunction(innerPromise.on)) {\n            innerPromise.on(`progress`, emitter.emit.bind(emitter, `progress`));\n            innerPromise.on(`upload-progress`, emitter.emit.bind(emitter, `upload-progress`));\n            innerPromise.on(`download-progress`, emitter.emit.bind(emitter, `download-progress`));\n          }\n\n          return innerPromise\n            .then((res) => {\n              cb(null, res);\n            })\n            .catch((reason) => {\n              if (!reason) {\n                reason = new Error(`retryable method failed without providing an error object`);\n              }\n              cb(reason);\n            });\n        },\n        (err, res) => {\n          if (err) {\n            return reject(err);\n          }\n\n          return resolve(res);\n        }\n      );\n\n      call.setStrategy(new backoff.ExponentialStrategy(strategyOptions));\n      if (options.maxAttempts) {\n        call.failAfter(options.maxAttempts - 1);\n      }\n\n      call.start();\n    });\n\n    promise.on = function on(key, callback) {\n      emitter.on(key, callback);\n      return promise;\n    };\n\n    return promise;\n  };\n}\n"]}